// Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"cmd/internal/obj"
	"cmd/internal/obj/arm64"
)
import "cmd/internal/gc"

const (
	LeftRdwr  uint32 = gc.LeftRead | gc.LeftWrite
	RightRdwr uint32 = gc.RightRead | gc.RightWrite
)

// This table gives the basic information about instruction
// generated by the compiler and processed in the optimizer.
// See opt.h for bit definitions.
//
// Instructions not generated need not be listed.
// As an exception to that rule, we typically write down all the
// size variants of an operation even if we just use a subset.
//
// The table is formatted for 8-space tabs.
var progtable = [arm64.ALAST]gc.ProgInfo{
	obj.ATYPE:     gc.ProgInfo{gc.Pseudo | gc.Skip, 0, 0, 0},
	obj.ATEXT:     gc.ProgInfo{gc.Pseudo, 0, 0, 0},
	obj.AFUNCDATA: gc.ProgInfo{gc.Pseudo, 0, 0, 0},
	obj.APCDATA:   gc.ProgInfo{gc.Pseudo, 0, 0, 0},
	obj.AUNDEF:    gc.ProgInfo{gc.Break, 0, 0, 0},
	obj.AUSEFIELD: gc.ProgInfo{gc.OK, 0, 0, 0},
	obj.ACHECKNIL: gc.ProgInfo{gc.LeftRead, 0, 0, 0},
	obj.AVARDEF:   gc.ProgInfo{gc.Pseudo | gc.RightWrite, 0, 0, 0},
	obj.AVARKILL:  gc.ProgInfo{gc.Pseudo | gc.RightWrite, 0, 0, 0},

	// NOP is an internal no-op that also stands
	// for USED and SET annotations, not the Power opcode.
	obj.ANOP: gc.ProgInfo{gc.LeftRead | gc.RightWrite, 0, 0, 0},

	// Integer
	arm64.AADD:    gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.ASUB:    gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.ANEG:    gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AAND:    gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AOR:     gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AXOR:    gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AMULLD:  gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AMULLW:  gc.ProgInfo{gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AMULHD:  gc.ProgInfo{gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AMULHDU: gc.ProgInfo{gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.ADIVD:   gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.ADIVDU:  gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.ASLD:    gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.ASRD:    gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.ASRAD:   gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.ACMP:    gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RightRead, 0, 0, 0},
	arm64.ACMPU:   gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RightRead, 0, 0, 0},
	arm64.ATD:     gc.ProgInfo{gc.SizeQ | gc.RightRead, 0, 0, 0},

	// Floating point.
	arm64.AFADD:   gc.ProgInfo{gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AFADDS:  gc.ProgInfo{gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AFSUB:   gc.ProgInfo{gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AFSUBS:  gc.ProgInfo{gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AFMUL:   gc.ProgInfo{gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AFMULS:  gc.ProgInfo{gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AFDIV:   gc.ProgInfo{gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AFDIVS:  gc.ProgInfo{gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AFCTIDZ: gc.ProgInfo{gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AFCFID:  gc.ProgInfo{gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite, 0, 0, 0},
	arm64.AFCMPU:  gc.ProgInfo{gc.SizeD | gc.LeftRead | gc.RightRead, 0, 0, 0},
	arm64.AFRSP:   gc.ProgInfo{gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv, 0, 0, 0},

	// Moves
	arm64.AMOVB:  gc.ProgInfo{gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},
	arm64.AMOVBU: gc.ProgInfo{gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv | gc.PostInc, 0, 0, 0},
	arm64.AMOVBZ: gc.ProgInfo{gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},
	arm64.AMOVH:  gc.ProgInfo{gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},
	arm64.AMOVHU: gc.ProgInfo{gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv | gc.PostInc, 0, 0, 0},
	arm64.AMOVHZ: gc.ProgInfo{gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},
	arm64.AMOVW:  gc.ProgInfo{gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},

	// there is no AMOVWU.
	arm64.AMOVWZU: gc.ProgInfo{gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv | gc.PostInc, 0, 0, 0},
	arm64.AMOVWZ:  gc.ProgInfo{gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},
	arm64.AMOVD:   gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Move, 0, 0, 0},
	arm64.AMOVDU:  gc.ProgInfo{gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Move | gc.PostInc, 0, 0, 0},
	arm64.AFMOVS:  gc.ProgInfo{gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv, 0, 0, 0},
	arm64.AFMOVD:  gc.ProgInfo{gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Move, 0, 0, 0},

	// Jumps
	arm64.ABR:     gc.ProgInfo{gc.Jump | gc.Break, 0, 0, 0},
	arm64.ABL:     gc.ProgInfo{gc.Call, 0, 0, 0},
	arm64.ABEQ:    gc.ProgInfo{gc.Cjmp, 0, 0, 0},
	arm64.ABNE:    gc.ProgInfo{gc.Cjmp, 0, 0, 0},
	arm64.ABGE:    gc.ProgInfo{gc.Cjmp, 0, 0, 0},
	arm64.ABLT:    gc.ProgInfo{gc.Cjmp, 0, 0, 0},
	arm64.ABGT:    gc.ProgInfo{gc.Cjmp, 0, 0, 0},
	arm64.ABLE:    gc.ProgInfo{gc.Cjmp, 0, 0, 0},
	arm64.ARETURN: gc.ProgInfo{gc.Break, 0, 0, 0},
	obj.ADUFFZERO: gc.ProgInfo{gc.Call, 0, 0, 0},
	obj.ADUFFCOPY: gc.ProgInfo{gc.Call, 0, 0, 0},
}

var initproginfo_initialized int

func initproginfo() {
	var addvariant = []int{V_CC, V_V, V_CC | V_V}

	if initproginfo_initialized != 0 {
		return
	}
	initproginfo_initialized = 1

	// Perform one-time expansion of instructions in progtable to
	// their CC, V, and VCC variants
	var as2 int
	var i int
	var variant int
	for as := int(0); as < len(progtable); as++ {
		if progtable[as].Flags == 0 {
			continue
		}
		variant = as2variant(as)
		for i = 0; i < len(addvariant); i++ {
			as2 = variant2as(as, variant|addvariant[i])
			if as2 != 0 && progtable[as2].Flags == 0 {
				progtable[as2] = progtable[as]
			}
		}
	}
}

func proginfo(info *gc.ProgInfo, p *obj.Prog) {
	initproginfo()

	*info = progtable[p.As]
	if info.Flags == 0 {
		*info = progtable[arm64.AADD]
		gc.Fatal("proginfo: unknown instruction %v", p)
	}

	if (info.Flags&gc.RegRead != 0) && p.Reg == 0 {
		info.Flags &^= gc.RegRead
		info.Flags |= gc.RightRead /*CanRegRead |*/
	}

	if (p.From.Type == obj.TYPE_MEM || p.From.Type == obj.TYPE_ADDR) && p.From.Reg != 0 {
		info.Regindex |= RtoB(int(p.From.Reg))
		if info.Flags&gc.PostInc != 0 {
			info.Regset |= RtoB(int(p.From.Reg))
		}
	}

	if (p.To.Type == obj.TYPE_MEM || p.To.Type == obj.TYPE_ADDR) && p.To.Reg != 0 {
		info.Regindex |= RtoB(int(p.To.Reg))
		if info.Flags&gc.PostInc != 0 {
			info.Regset |= RtoB(int(p.To.Reg))
		}
	}

	if p.From.Type == obj.TYPE_ADDR && p.From.Sym != nil && (info.Flags&gc.LeftRead != 0) {
		info.Flags &^= gc.LeftRead
		info.Flags |= gc.LeftAddr
	}

	if p.As == obj.ADUFFZERO {
		info.Reguse |= 1<<0 | RtoB(arm64.REG_R3)
		info.Regset |= RtoB(arm64.REG_R3)
	}

	if p.As == obj.ADUFFCOPY {
		// TODO(austin) Revisit when duffcopy is implemented
		info.Reguse |= RtoB(arm64.REG_R3) | RtoB(arm64.REG_R4) | RtoB(arm64.REG_R5)

		info.Regset |= RtoB(arm64.REG_R3) | RtoB(arm64.REG_R4)
	}
}

// Instruction variants table.  Initially this contains entries only
// for the "base" form of each instruction.  On the first call to
// as2variant or variant2as, we'll add the variants to the table.
var varianttable = [arm64.ALAST][4]int{
	arm64.AADD:     [4]int{arm64.AADD, arm64.AADDCC, arm64.AADDV, arm64.AADDVCC},
	arm64.AADDC:    [4]int{arm64.AADDC, arm64.AADDCCC, arm64.AADDCV, arm64.AADDCVCC},
	arm64.AADDE:    [4]int{arm64.AADDE, arm64.AADDECC, arm64.AADDEV, arm64.AADDEVCC},
	arm64.AADDME:   [4]int{arm64.AADDME, arm64.AADDMECC, arm64.AADDMEV, arm64.AADDMEVCC},
	arm64.AADDZE:   [4]int{arm64.AADDZE, arm64.AADDZECC, arm64.AADDZEV, arm64.AADDZEVCC},
	arm64.AAND:     [4]int{arm64.AAND, arm64.AANDCC, 0, 0},
	arm64.AANDN:    [4]int{arm64.AANDN, arm64.AANDNCC, 0, 0},
	arm64.ACNTLZD:  [4]int{arm64.ACNTLZD, arm64.ACNTLZDCC, 0, 0},
	arm64.ACNTLZW:  [4]int{arm64.ACNTLZW, arm64.ACNTLZWCC, 0, 0},
	arm64.ADIVD:    [4]int{arm64.ADIVD, arm64.ADIVDCC, arm64.ADIVDV, arm64.ADIVDVCC},
	arm64.ADIVDU:   [4]int{arm64.ADIVDU, arm64.ADIVDUCC, arm64.ADIVDUV, arm64.ADIVDUVCC},
	arm64.ADIVW:    [4]int{arm64.ADIVW, arm64.ADIVWCC, arm64.ADIVWV, arm64.ADIVWVCC},
	arm64.ADIVWU:   [4]int{arm64.ADIVWU, arm64.ADIVWUCC, arm64.ADIVWUV, arm64.ADIVWUVCC},
	arm64.AEQV:     [4]int{arm64.AEQV, arm64.AEQVCC, 0, 0},
	arm64.AEXTSB:   [4]int{arm64.AEXTSB, arm64.AEXTSBCC, 0, 0},
	arm64.AEXTSH:   [4]int{arm64.AEXTSH, arm64.AEXTSHCC, 0, 0},
	arm64.AEXTSW:   [4]int{arm64.AEXTSW, arm64.AEXTSWCC, 0, 0},
	arm64.AFABS:    [4]int{arm64.AFABS, arm64.AFABSCC, 0, 0},
	arm64.AFADD:    [4]int{arm64.AFADD, arm64.AFADDCC, 0, 0},
	arm64.AFADDS:   [4]int{arm64.AFADDS, arm64.AFADDSCC, 0, 0},
	arm64.AFCFID:   [4]int{arm64.AFCFID, arm64.AFCFIDCC, 0, 0},
	arm64.AFCTID:   [4]int{arm64.AFCTID, arm64.AFCTIDCC, 0, 0},
	arm64.AFCTIDZ:  [4]int{arm64.AFCTIDZ, arm64.AFCTIDZCC, 0, 0},
	arm64.AFCTIW:   [4]int{arm64.AFCTIW, arm64.AFCTIWCC, 0, 0},
	arm64.AFCTIWZ:  [4]int{arm64.AFCTIWZ, arm64.AFCTIWZCC, 0, 0},
	arm64.AFDIV:    [4]int{arm64.AFDIV, arm64.AFDIVCC, 0, 0},
	arm64.AFDIVS:   [4]int{arm64.AFDIVS, arm64.AFDIVSCC, 0, 0},
	arm64.AFMADD:   [4]int{arm64.AFMADD, arm64.AFMADDCC, 0, 0},
	arm64.AFMADDS:  [4]int{arm64.AFMADDS, arm64.AFMADDSCC, 0, 0},
	arm64.AFMOVD:   [4]int{arm64.AFMOVD, arm64.AFMOVDCC, 0, 0},
	arm64.AFMSUB:   [4]int{arm64.AFMSUB, arm64.AFMSUBCC, 0, 0},
	arm64.AFMSUBS:  [4]int{arm64.AFMSUBS, arm64.AFMSUBSCC, 0, 0},
	arm64.AFMUL:    [4]int{arm64.AFMUL, arm64.AFMULCC, 0, 0},
	arm64.AFMULS:   [4]int{arm64.AFMULS, arm64.AFMULSCC, 0, 0},
	arm64.AFNABS:   [4]int{arm64.AFNABS, arm64.AFNABSCC, 0, 0},
	arm64.AFNEG:    [4]int{arm64.AFNEG, arm64.AFNEGCC, 0, 0},
	arm64.AFNMADD:  [4]int{arm64.AFNMADD, arm64.AFNMADDCC, 0, 0},
	arm64.AFNMADDS: [4]int{arm64.AFNMADDS, arm64.AFNMADDSCC, 0, 0},
	arm64.AFNMSUB:  [4]int{arm64.AFNMSUB, arm64.AFNMSUBCC, 0, 0},
	arm64.AFNMSUBS: [4]int{arm64.AFNMSUBS, arm64.AFNMSUBSCC, 0, 0},
	arm64.AFRES:    [4]int{arm64.AFRES, arm64.AFRESCC, 0, 0},
	arm64.AFRSP:    [4]int{arm64.AFRSP, arm64.AFRSPCC, 0, 0},
	arm64.AFRSQRTE: [4]int{arm64.AFRSQRTE, arm64.AFRSQRTECC, 0, 0},
	arm64.AFSEL:    [4]int{arm64.AFSEL, arm64.AFSELCC, 0, 0},
	arm64.AFSQRT:   [4]int{arm64.AFSQRT, arm64.AFSQRTCC, 0, 0},
	arm64.AFSQRTS:  [4]int{arm64.AFSQRTS, arm64.AFSQRTSCC, 0, 0},
	arm64.AFSUB:    [4]int{arm64.AFSUB, arm64.AFSUBCC, 0, 0},
	arm64.AFSUBS:   [4]int{arm64.AFSUBS, arm64.AFSUBSCC, 0, 0},
	arm64.AMTFSB0:  [4]int{arm64.AMTFSB0, arm64.AMTFSB0CC, 0, 0},
	arm64.AMTFSB1:  [4]int{arm64.AMTFSB1, arm64.AMTFSB1CC, 0, 0},
	arm64.AMULHD:   [4]int{arm64.AMULHD, arm64.AMULHDCC, 0, 0},
	arm64.AMULHDU:  [4]int{arm64.AMULHDU, arm64.AMULHDUCC, 0, 0},
	arm64.AMULHW:   [4]int{arm64.AMULHW, arm64.AMULHWCC, 0, 0},
	arm64.AMULHWU:  [4]int{arm64.AMULHWU, arm64.AMULHWUCC, 0, 0},
	arm64.AMULLD:   [4]int{arm64.AMULLD, arm64.AMULLDCC, arm64.AMULLDV, arm64.AMULLDVCC},
	arm64.AMULLW:   [4]int{arm64.AMULLW, arm64.AMULLWCC, arm64.AMULLWV, arm64.AMULLWVCC},
	arm64.ANAND:    [4]int{arm64.ANAND, arm64.ANANDCC, 0, 0},
	arm64.ANEG:     [4]int{arm64.ANEG, arm64.ANEGCC, arm64.ANEGV, arm64.ANEGVCC},
	arm64.ANOR:     [4]int{arm64.ANOR, arm64.ANORCC, 0, 0},
	arm64.AOR:      [4]int{arm64.AOR, arm64.AORCC, 0, 0},
	arm64.AORN:     [4]int{arm64.AORN, arm64.AORNCC, 0, 0},
	arm64.AREM:     [4]int{arm64.AREM, arm64.AREMCC, arm64.AREMV, arm64.AREMVCC},
	arm64.AREMD:    [4]int{arm64.AREMD, arm64.AREMDCC, arm64.AREMDV, arm64.AREMDVCC},
	arm64.AREMDU:   [4]int{arm64.AREMDU, arm64.AREMDUCC, arm64.AREMDUV, arm64.AREMDUVCC},
	arm64.AREMU:    [4]int{arm64.AREMU, arm64.AREMUCC, arm64.AREMUV, arm64.AREMUVCC},
	arm64.ARLDC:    [4]int{arm64.ARLDC, arm64.ARLDCCC, 0, 0},
	arm64.ARLDCL:   [4]int{arm64.ARLDCL, arm64.ARLDCLCC, 0, 0},
	arm64.ARLDCR:   [4]int{arm64.ARLDCR, arm64.ARLDCRCC, 0, 0},
	arm64.ARLDMI:   [4]int{arm64.ARLDMI, arm64.ARLDMICC, 0, 0},
	arm64.ARLWMI:   [4]int{arm64.ARLWMI, arm64.ARLWMICC, 0, 0},
	arm64.ARLWNM:   [4]int{arm64.ARLWNM, arm64.ARLWNMCC, 0, 0},
	arm64.ASLD:     [4]int{arm64.ASLD, arm64.ASLDCC, 0, 0},
	arm64.ASLW:     [4]int{arm64.ASLW, arm64.ASLWCC, 0, 0},
	arm64.ASRAD:    [4]int{arm64.ASRAD, arm64.ASRADCC, 0, 0},
	arm64.ASRAW:    [4]int{arm64.ASRAW, arm64.ASRAWCC, 0, 0},
	arm64.ASRD:     [4]int{arm64.ASRD, arm64.ASRDCC, 0, 0},
	arm64.ASRW:     [4]int{arm64.ASRW, arm64.ASRWCC, 0, 0},
	arm64.ASUB:     [4]int{arm64.ASUB, arm64.ASUBCC, arm64.ASUBV, arm64.ASUBVCC},
	arm64.ASUBC:    [4]int{arm64.ASUBC, arm64.ASUBCCC, arm64.ASUBCV, arm64.ASUBCVCC},
	arm64.ASUBE:    [4]int{arm64.ASUBE, arm64.ASUBECC, arm64.ASUBEV, arm64.ASUBEVCC},
	arm64.ASUBME:   [4]int{arm64.ASUBME, arm64.ASUBMECC, arm64.ASUBMEV, arm64.ASUBMEVCC},
	arm64.ASUBZE:   [4]int{arm64.ASUBZE, arm64.ASUBZECC, arm64.ASUBZEV, arm64.ASUBZEVCC},
	arm64.AXOR:     [4]int{arm64.AXOR, arm64.AXORCC, 0, 0},
}

var initvariants_initialized int

func initvariants() {
	if initvariants_initialized != 0 {
		return
	}
	initvariants_initialized = 1

	var j int
	for i := int(0); i < len(varianttable); i++ {
		if varianttable[i][0] == 0 {
			// Instruction has no variants
			varianttable[i][0] = i

			continue
		}

		// Copy base form to other variants
		if varianttable[i][0] == i {
			for j = 0; j < len(varianttable[i]); j++ {
				varianttable[varianttable[i][j]] = varianttable[i]
			}
		}
	}
}

// as2variant returns the variant (V_*) flags of instruction as.
func as2variant(as int) int {
	initvariants()
	for i := int(0); i < len(varianttable[as]); i++ {
		if varianttable[as][i] == as {
			return i
		}
	}
	gc.Fatal("as2variant: instruction %v is not a variant of itself", arm64.Aconv(as))
	return 0
}

// variant2as returns the instruction as with the given variant (V_*) flags.
// If no such variant exists, this returns 0.
func variant2as(as int, flags int) int {
	initvariants()
	return varianttable[as][flags]
}
